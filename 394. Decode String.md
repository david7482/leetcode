### [394\. Decode String](https://leetcode.com/problems/decode-string/)

Difficulty: **Medium**

Related Topics: [String](https://leetcode.com/tag/string/), [Stack](https://leetcode.com/tag/stack/), [Recursion](https://leetcode.com/tag/recursion/)


Given an encoded string, return its decoded string.

The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.

You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.

Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there won't be input like `3a` or `2[4]`.

**Example 1:**

```
Input: s = "3[a]2[bc]"
Output: "aaabcbc"
```

**Example 2:**

```
Input: s = "3[a2[c]]"
Output: "accaccacc"
```

**Example 3:**

```
Input: s = "2[abc]3[cd]ef"
Output: "abcabccdcdcdef"
```

**Example 4:**

```
Input: s = "abc3[cd]xyz"
Output: "abccdcdcdxyz"
```

**Constraints:**

*   `1 <= s.length <= 30`
*   `s` consists of lowercase English letters, digits, and square brackets `'[]'`.
*   `s` is guaranteed to be **a valid** input.
*   All the integers in `s` are in the range `[1, 300]`.


#### Solution

Language: **C++**

```c++
class Solution {
public:
    string decodeString(string s) {
        int index = 0;
        return helper(s, index);
    }
    
    string helper(string &s, int &index) {
        string ret;
        int k = 0;
        while (index < s.size()) {
            char c = s[index];
            if (c >= 'a' && c <= 'z') {
                ret.push_back(c);
            } else if (c >= '0' && c <= '9') {
                k = k * 10 + (c - '0');
            } else if (c == '[') {
                index++;
                string tmp = helper(s, index);
                for (int i = 0; i < k; i++) ret = ret + tmp;
                k = 0;
            } else if (c == ']') {
                return ret;
            }
            
            index++;
        }
        
        return ret;        
    }
};
```